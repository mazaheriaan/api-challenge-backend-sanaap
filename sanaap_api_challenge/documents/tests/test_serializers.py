from unittest.mock import patch

from django.contrib.auth import get_user_model
from django.core.files.uploadedfile import SimpleUploadedFile
from django.test import TestCase
from rest_framework.test import APIRequestFactory

from sanaap_api_challenge.documents.api.serializers import AccessLogSerializer
from sanaap_api_challenge.documents.api.serializers import BulkShareSerializer
from sanaap_api_challenge.documents.api.serializers import DocumentCreateSerializer
from sanaap_api_challenge.documents.api.serializers import DocumentDetailSerializer
from sanaap_api_challenge.documents.api.serializers import DocumentListSerializer
from sanaap_api_challenge.documents.api.serializers import ShareSerializer
from sanaap_api_challenge.documents.api.serializers import UserSerializer

from .factories import AccessFactory
from .factories import DocumentFactory
from .factories import ShareFactory
from .factories import UserFactory

User = get_user_model()


class TestUserSerializer(TestCase):
    def test_user_serialization(self):
        user = UserFactory(
            username="testuser",
            first_name="Test",
            last_name="User",
            email="test@example.com",
        )

        serializer = UserSerializer(user)
        data = serializer.data

        self.assertEqual(data["id"], user.id)
        self.assertEqual(data["username"], "testuser")
        self.assertEqual(data["first_name"], "Test")
        self.assertEqual(data["last_name"], "User")
        self.assertEqual(data["email"], "test@example.com")

    def test_user_fields_readonly(self):
        serializer = UserSerializer()
        readonly_fields = serializer.Meta.read_only_fields

        self.assertIn("id", readonly_fields)
        self.assertIn("username", readonly_fields)
        self.assertIn("first_name", readonly_fields)
        self.assertIn("last_name", readonly_fields)
        self.assertIn("email", readonly_fields)


class TestDocumentListSerializer(TestCase):
    def setUp(self):
        self.user = UserFactory()
        self.document = DocumentFactory(
            owner=self.user,
            title="Test Document",
            description="Test Description",
            file_path="documents/test.pdf",
            file_hash="abc123",
            file_size=1024,
            is_public=True,
        )

    def test_document_list_serialization(self):
        serializer = DocumentListSerializer(self.document)
        data = serializer.data

        self.assertEqual(data["id"], self.document.id)
        self.assertEqual(data["title"], "Test Document")
        self.assertEqual(data["description"], "Test Description")
        self.assertEqual(data["owner"]["id"], self.user.id)
        # File extension depends on the random filename generated by factory
        self.assertIn("file_extension", data)
        self.assertIsInstance(data["file_extension"], str)
        self.assertEqual(data["file_size_display"], "1.0 KB")
        self.assertEqual(data["is_public"], True)
        self.assertIn("created", data)
        self.assertIn("modified", data)

    def test_owner_nested_representation(self):
        serializer = DocumentListSerializer(self.document)
        owner_data = serializer.data["owner"]

        self.assertEqual(owner_data["id"], self.user.id)
        self.assertEqual(owner_data["username"], self.user.username)
        self.assertIn("email", owner_data)


class TestDocumentDetailSerializer(TestCase):
    def setUp(self):
        self.user = UserFactory()
        self.document = DocumentFactory(owner=self.user)

    def test_document_detail_serialization(self):
        # Create some shares and access logs
        share = ShareFactory(document=self.document)
        access = AccessFactory(document=self.document)

        serializer = DocumentDetailSerializer(self.document)
        data = serializer.data

        self.assertEqual(data["id"], self.document.id)
        self.assertIn("shares", data)
        self.assertIn("recent_access", data)
        self.assertIn("download_url", data)

    def test_shares_included(self):
        share1 = ShareFactory(document=self.document)
        share2 = ShareFactory(document=self.document)

        serializer = DocumentDetailSerializer(self.document)
        shares_data = serializer.data["shares"]

        self.assertEqual(len(shares_data), 2)
        share_ids = [share["id"] for share in shares_data]
        self.assertIn(share1.id, share_ids)
        self.assertIn(share2.id, share_ids)


class TestDocumentCreateSerializer(TestCase):
    def setUp(self):
        self.user = UserFactory()
        self.factory = APIRequestFactory()

    @patch("sanaap_api_challenge.utils.minio_client.minio_client")
    def test_create_document_valid_data(self, mock_minio):
        mock_minio.upload_file.return_value = True
        mock_minio.file_exists.return_value = True

        file = SimpleUploadedFile(
            "test.txt", b"test content", content_type="text/plain"
        )

        # Create a request with user
        request = self.factory.post("/")
        request.user = self.user

        serializer = DocumentCreateSerializer(
            data={"title": "Test Doc", "file": file, "description": "Test"},
            context={"request": request},
        )

        self.assertTrue(serializer.is_valid())
        document = serializer.save()
        self.assertEqual(document.owner, self.user)
        self.assertEqual(document.title, "Test Doc")

    def test_create_document_invalid_file_type(self):
        file = SimpleUploadedFile(
            "test.exe", b"test content", content_type="application/octet-stream"
        )

        request = self.factory.post("/")
        request.user = self.user

        serializer = DocumentCreateSerializer(
            data={"title": "Test Doc", "file": file},
            context={"request": request},
        )

        self.assertFalse(serializer.is_valid())
        self.assertIn("file", serializer.errors)

    def test_create_document_file_too_large(self):
        # Create file larger than 50MB limit for documents
        large_content = b"x" * (60 * 1024 * 1024)
        file = SimpleUploadedFile("test.txt", large_content, content_type="text/plain")

        request = self.factory.post("/")
        request.user = self.user

        serializer = DocumentCreateSerializer(
            data={"title": "Test Doc", "file": file},
            context={"request": request},
        )

        self.assertFalse(serializer.is_valid())
        self.assertIn("file", serializer.errors)


class TestShareSerializer(TestCase):
    def setUp(self):
        self.user = UserFactory()
        self.document = DocumentFactory(owner=self.user)
        self.shared_with_user = UserFactory()

    def test_share_serialization(self):
        share = ShareFactory(
            document=self.document,
            shared_by=self.user,
            shared_with=self.shared_with_user,
            permission_level="view",
        )

        serializer = ShareSerializer(share)
        data = serializer.data

        self.assertEqual(data["id"], share.id)
        self.assertEqual(data["document"], self.document.id)
        self.assertEqual(data["shared_with"]["id"], self.shared_with_user.id)
        self.assertEqual(data["permission_level"], "view")
        self.assertIn("expires_at", data)

    def test_share_creation_valid_data(self):
        data = {
            "document": self.document.id,
            "shared_with_id": self.shared_with_user.id,
            "permission_level": "edit",
        }

        serializer = ShareSerializer(
            data=data,
            context={
                "document": self.document,
                "request": type("obj", (object,), {"user": self.user})(),
            },
        )
        self.assertTrue(serializer.is_valid())
        share = serializer.save()
        self.assertEqual(share.shared_by, self.user)
        self.assertEqual(share.permission_level, "edit")

    def test_share_permission_choices(self):
        # Test that the permission_level field exists and has valid choices
        serializer = ShareSerializer()
        self.assertIn("permission_level", serializer.fields)
        # Just verify the field exists - the specific choices are from the model
        self.assertTrue(hasattr(serializer.fields["permission_level"], "choices"))


class TestBulkShareSerializer(TestCase):
    def setUp(self):
        self.user = UserFactory()
        self.document = DocumentFactory(owner=self.user)

    def test_bulk_share_valid_data(self):
        user1 = UserFactory()
        user2 = UserFactory()
        user3 = UserFactory()

        data = {
            "user_ids": [user1.id, user2.id, user3.id],
            "permission_level": "view",
        }

        serializer = BulkShareSerializer(data=data)
        self.assertTrue(serializer.is_valid())

        # Verify the validated data
        validated = serializer.validated_data
        self.assertEqual(len(validated["user_ids"]), 3)
        self.assertEqual(validated["permission_level"], "view")

    def test_bulk_share_empty_users(self):
        data = {
            "user_ids": [],
            "permission_level": "view",
        }

        serializer = BulkShareSerializer(data=data)
        self.assertFalse(serializer.is_valid())
        self.assertIn("user_ids", serializer.errors)


class TestAccessLogSerializer(TestCase):
    def test_access_log_serialization(self):
        user = UserFactory()
        document = DocumentFactory()
        access = AccessFactory(
            document=document,
            user=user,
            action="view",
            ip_address="192.168.1.1",
        )

        serializer = AccessLogSerializer(access)
        data = serializer.data

        self.assertEqual(data["id"], access.id)
        self.assertEqual(data["user"]["id"], user.id)
        self.assertEqual(data["action"], "view")
        self.assertEqual(data["ip_address"], "192.168.1.1")
        self.assertIn("created", data)

    def test_readonly_fields(self):
        serializer = AccessLogSerializer()

        # All fields should be read-only
        for field_name, field in serializer.fields.items():
            self.assertTrue(
                field.read_only,
                f"Field {field_name} should be read-only",
            )
